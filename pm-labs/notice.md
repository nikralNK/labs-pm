# Лабораторная работа 25: Обработка матриц с автозаполнением и сортировкой

## Описание работы программы

Приложение для работы с двумерными массивами (матрицами) с возможностью автоматического и ручного заполнения. Каждый третий столбец автоматически вычисляется как разность двух предыдущих. Реализована селекция массива по строкам или столбцам с сортировкой методом пузырька по сумме положительных элементов.

## Основная функциональность

1. **Ввод размерности матрицы** - количество строк и столбцов (от 1 до 20)
2. **Выбор способа заполнения**:
   - Автоматически (случайные числа от -50 до 50)
   - Вручную (пользователь вводит значения)
3. **Автозаполнение каждого третьего столбца** - вычисляется как разность двух предыдущих столбцов
4. **Селекция массива**:
   - По строкам
   - По столбцам
5. **Сортировка методом пузырька** по сумме положительных элементов

## Компоненты формы

### Ввод данных

- **txtRows** - TextBox для ввода количества строк
- **txtCols** - TextBox для ввода количества столбцов
- **grpFillMethod** - GroupBox с выбором способа заполнения
  - **rbAuto** - RadioButton для автоматического заполнения
  - **rbManual** - RadioButton для ручного заполнения
- **btnCreateMatrix** - Button для создания матрицы

### Отображение матрицы

- **dgvMatrix** - DataGridView для отображения и редактирования матрицы

### Обработка

- **grpSelection** - GroupBox с выбором способа селекции
  - **rbByRows** - RadioButton для селекции по строкам
  - **rbByColumns** - RadioButton для селекции по столбцам
- **btnProcess** - Button для запуска обработки

### Вывод результата

- **lstResult** - ListBox для отображения отсортированных массивов

## Основные методы

### btnCreateMatrix_Click

Создает матрицу заданного размера:

1. Валидация введенных размеров (1-20)
2. Очистка dgvMatrix.Rows и dgvMatrix.Columns
3. Создание столбцов:
   - Каждый третий столбец делается ReadOnly
   - Серый фон для автозаполняемых столбцов: `column.DefaultCellStyle.BackColor = Color.LightGray`
   - Проверка: `if ((j + 1) % 3 == 0)`
4. Добавление строк с заголовками
5. Если выбрано автозаполнение - вызов FillMatrixAutomatically()

### FillMatrixAutomatically

Автоматическое заполнение матрицы случайными числами:

```csharp
for (int i = 0; i < rows; i++)
{
    for (int j = 0; j < cols; j++)
    {
        if ((j + 1) % 3 != 0)
        {
            dgvMatrix.Rows[i].Cells[j].Value = rand.Next(-50, 51);
        }
    }
}
CalculateThirdColumns();
```

Заполняет только первые два столбца из каждой тройки, третий вычисляется отдельно.

### dgvMatrix_CellValueChanged

Обработчик изменения значения ячейки (для ручного ввода):

1. Проверка флага isProcessingCellChange (предотвращение рекурсии)
2. Проверка индексов rowIndex и colIndex
3. Если изменен второй столбец из тройки: `if ((colIndex + 1) % 3 == 2)`
4. Вызов CalculateThirdColumnForRow() для пересчета третьего столбца

**Важно:** Используется флаг isProcessingCellChange для предотвращения бесконечной рекурсии при программном изменении ячеек.

### CalculateThirdColumnForRow

Вычисляет значение третьего столбца для конкретной строки:

```csharp
int firstColIndex = colIndex - 1;
int secondColIndex = colIndex;
int thirdColIndex = colIndex + 1;

dgvMatrix.Rows[rowIndex].Cells[thirdColIndex].Value = val2 - val1;
```

Формула: **Столбец3 = Столбец2 - Столбец1**

### CalculateThirdColumns

Вычисляет все третьи столбцы для всей матрицы (при автозаполнении):

```csharp
for (int j = 1; j < cols; j += 3)
{
    int firstColIndex = j - 1;
    int secondColIndex = j;
    int thirdColIndex = j + 1;

    dgvMatrix.Rows[i].Cells[thirdColIndex].Value = val2 - val1;
}
```

Проходит по столбцам с шагом 3, начиная со второго (индекс 1).

### btnProcess_Click

Основная обработка матрицы:

1. **Валидация**:
   - Проверка существования матрицы
   - Проверка заполненности всех ячеек

2. **Селекция**:
   - Если rbByRows.Checked - извлечение строк
   - Если rbByColumns.Checked - извлечение столбцов

3. **Подсчет суммы положительных**:
```csharp
for (int j = 0; j < cols; j++)
{
    if (int.TryParse(dgvMatrix.Rows[i].Cells[j].Value.ToString(), out int val))
    {
        rowData.Add(val);
        if (val > 0)
            positiveSum += val;
    }
}
```

4. **Создание объектов ArrayInfo**:
```csharp
arrays.Add(new ArrayInfo
{
    Data = rowData.ToArray(),
    PositiveSum = positiveSum,
    Index = i
});
```

5. **Сортировка методом пузырька**:
```csharp
BubbleSort(arrays);
```

6. **Вывод результатов** в lstResult

### BubbleSort

Классическая реализация сортировки методом пузырька:

```csharp
for (int i = 0; i < n - 1; i++)
{
    for (int j = 0; j < n - i - 1; j++)
    {
        if (arrays[j].PositiveSum > arrays[j + 1].PositiveSum)
        {
            ArrayInfo temp = arrays[j];
            arrays[j] = arrays[j + 1];
            arrays[j + 1] = temp;
        }
    }
}
```

Сортирует массивы по возрастанию суммы положительных элементов.

**Сложность:** O(n²)

## Вспомогательный класс ArrayInfo

```csharp
private class ArrayInfo
{
    public int[] Data { get; set; }         // Данные массива
    public int PositiveSum { get; set; }     // Сумма положительных элементов
    public int Index { get; set; }           // Исходный индекс строки/столбца
}
```

Хранит информацию об одном массиве (строке или столбце) для сортировки.

## Логика автозаполнения третьих столбцов

### Нумерация столбцов (начиная с 0):

- Столбец 0, 1, **2** - первая тройка (2 автозаполняется)
- Столбец 3, 4, **5** - вторая тройка (5 автозаполняется)
- Столбец 6, 7, **8** - третья тройка (8 автозаполняется)

### Условие определения третьего столбца:

```csharp
if ((j + 1) % 3 == 0)  // j=2, j=5, j=8, ...
```

### Формула вычисления:

```
Столбец[i][j] = Столбец[i][j-1] - Столбец[i][j-2]
```

Где:
- j - индекс третьего столбца (2, 5, 8, ...)
- j-1 - индекс второго столбца (1, 4, 7, ...)
- j-2 - индекс первого столбца (0, 3, 6, ...)

## Пример работы

### Входные данные:
- Строк: 3
- Столбцов: 6
- Автозаполнение

### Матрица:
```
   Столбец 0  Столбец 1  Столбец 2  Столбец 3  Столбец 4  Столбец 5
   ─────────────────────────────────────────────────────────────────
0:     10         20         10         -5         15         20
1:     -3          7         10          8        -12        -20
2:     25         -5        -30         30         10        -20
```

Столбец 2 = Столбец 1 - Столбец 0 = 20 - 10 = 10
Столбец 5 = Столбец 4 - Столбец 3 = 15 - (-5) = 20

### Результат (по строкам, отсортировано):
```
Строка 1: [-3, 7, 10, 8, -12, -20] - Сумма положительных: 25
Строка 0: [10, 20, 10, -5, 15, 20] - Сумма положительных: 75
Строка 2: [25, -5, -30, 30, 10, -20] - Сумма положительных: 65
```

## Особенности реализации

1. **Предотвращение рекурсии** - флаг isProcessingCellChange
2. **Визуальное выделение** - серый фон для автозаполняемых столбцов
3. **Защита от редактирования** - ReadOnly для третьих столбцов
4. **Динамическое вычисление** - при изменении первых двух столбцов третий обновляется автоматически
5. **Полная валидация** - проверка размеров, заполненности, корректности данных
6. **Сохранение индексов** - в ArrayInfo хранится исходный индекс для вывода
7. **Гибкая селекция** - выбор между строками и столбцами
8. **Классический bubble sort** - O(n²) сложность, простая реализация

## Формат вывода результата

```
{Тип} {Индекс}: [{Элементы через запятую}] - Сумма положительных: {Сумма}
```

Пример:
```
Строка 0: [10, 20, 10, -5, 15, 20] - Сумма положительных: 75
Столбец 2: [10, 10, -30] - Сумма положительных: 20
```
